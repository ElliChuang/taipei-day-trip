<!DOCTYPE html> 
<html>
    <head> 
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8"/>   
        <title>Test</title>
        <link rel="stylesheet" type="text/css" />
        <style>
            .container {
                border: 5px solid grey;
                height: 400px;
                width: 200px;
                margin: auto;
                overflow: auto;
                display: inline-block;
            }

            .target-element {
                width: 100px;
                height: 100px;
                background: orange;
                margin: 450px auto;
            }
        </style>
    </head>
    <body>
        <!-- First Observer -->
        <div class="container container-one">
            <div class="target-element target-one"></div>
            <div class="target-element target-one"></div>
        </div>

        <script>
            // // First Observer
            // const containerOne = document.querySelector('.container-one')
            // const targetOne = document.querySelectorAll('.target-one') 

            // const optionsOne = {
            // root: containerOne,
            // rootMargin: "0px",
            // threshold: 0
            // }

            // let callbackOne = (entries) => {
            //     console.log(entries)
            //     entries.forEach(entry =>{
            //         if (entry.isIntersecting) {
            //             console.log("yes")
            //     } 
            //     })
                
            // }

            // const observerOne = new IntersectionObserver(callbackOne, optionsOne)

            // // observe multiple elements: loop through each target
            // targetOne.forEach(target => observerOne.observe(target))


            // let mingRunPromise = (someone) => {
            //     let ran = parseInt(Math.random() * 2); // 隨機成功或失敗
            //     console.log(`${someone} 開始跑`);
            //         return new Promise((resolve, reject) => {
            //             if (ran) {
            //             setTimeout(function(){
            //                 resolve(`${someone} 跑 3 秒時間(fulfilled)`);
            //             }, 3000);
            //             } else {
            //                 reject(new Error(`${someone} 跌倒失敗(rejected)`))
            //             }
            //     });
            // }

            // mingRunPromise('小明').then((data)=> {
            //     console.log(data);
            // }).catch((err)=> {
            //     console.log(err)
            // });

            // // 多人一起跑
            // let runPromise = (someone, timer, success = true) => {
            // console.log(`${someone} 開始跑`);
            //     return new Promise((resolve, reject) => {
            //         if (success) {
            //             setTimeout(function () {
            //                 resolve(`${someone} 跑 ${timer / 1000} 秒時間(fulfilled)`);
            //             }, timer);
            //             } else {
            //                 reject(new Error(`${someone} 跌倒失敗(rejected)`))
            //             }
            //     });
            // }

            // // race 僅會回傳一個最快完成的 resolve 或 reject
            // Promise.race([runPromise('小明', 3000), runPromise('漂亮阿姨', 2500)]).then((data) => {
            //     console.log('第一名', data); // 漂亮阿姨 跑 2.5 秒時間(fulfilled) <- 因為漂亮阿姨跑得快
            // }).catch(err => {
            //     console.log(err)
            // });

            // // All 會同時執行以下 Promise，在全部完成後統一回傳陣列
            // Promise.all([runPromise('小明', 3000), runPromise('漂亮阿姨', 2500)]).then((data) => {
            //     console.log('race', data); // ["小明 跑 3 秒時間(fulfilled)", "漂亮阿姨 跑 2.5 秒時間(fulfilled)"]
            // }).catch(err => {
            //     console.log(err)
            // });


            // // 接力賽，一個跑完換下一個
            // runPromise('小明', 3000).then(mingString => { 
            //         console.log(mingString); // 小明 跑 3 秒時間(fulfilled)
            //         return runPromise('漂亮阿姨', 2500);
            //     }).then((autieString) => {
            //         console.log(autieString); // 漂亮阿姨 跑 2.5 秒時間(fulfilled)
            //         return runPromise('杰倫', 2000) ;
            //     }).then((jayString) => {
            //         console.log(jayString); // 杰倫 跑 2 秒時間(fulfilled)
            // });



            // function promiseFn(num, time = 500) {
            //     return new Promise((resolve, reject) => {
            //         setTimeout(() => {
            //         num ? resolve(`${num}, 成功`) : reject('失敗');
            //         }, time);
            //     });
            //     }

            // const arrayData = [{num: 1, time: 500},
            //     {num: 2, time: 3000},
            //     {num: 3, time: 1500},
            //     {num: 4, time: 1000}
            // ];
            

            // // 透過 for...loop 的迴圈形式依序執行 promiseFn，待前一個執行完畢後才會進入下一個迴圈
            // async function seriesFn() {
            //     const data = [];
            //     // 依序執行
            //     for (let i = 0; i < arrayData.length; i++) {
            //         const item = arrayData[i];
            //         data.push(await promiseFn(item.num, item.time));
            //         console.log(item.num, '執行完畢')
            //     }
            //     console.log(data); // ["1, 成功", "2, 成功", "3, 成功", "4, 成功"]
            //     }
            // seriesFn();

        </script>
    </body>